<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shadow Arena – Online Learning AI</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, #1f2a44, #0f1222 60%);
      --panel: rgba(255, 255, 255, 0.04);
      --panel-strong: rgba(255, 255, 255, 0.08);
      --text: #e8ecff;
      --muted: #9fb0d1;
      --accent: #7cf0ff;
      --accent-2: #ff9ff3;
      --danger: #ff6b81;
      --safe: #4cd964;
      --shadow: 0 12px 36px rgba(0, 0, 0, 0.45);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      color: var(--text);
      background: var(--bg);
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    h1 { margin: 0; letter-spacing: 0.6px; font-size: 1.8rem; }
    .tagline { color: var(--muted); max-width: 720px; line-height: 1.5; }
    .layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .card h2 { margin: 0 0 8px; font-size: 1.1rem; letter-spacing: 0.3px; }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    button {
      background: linear-gradient(120deg, #3c4ca0, #6b5edc);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.2s;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }
    button:hover { transform: translateY(-2px); filter: brightness(1.05); }
    button:active { transform: translateY(0); filter: brightness(0.95); }
    button.secondary { background: #2f3645; }
    button.danger { background: linear-gradient(120deg, #ff4d6d, #ff6b81); }
    .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
    .stat { background: var(--panel-strong); padding: 10px; border-radius: 10px; text-align: center; }
    .stat .label { color: var(--muted); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.6px; }
    .stat .value { font-size: 1.2rem; font-weight: 800; }
    .pill { padding: 6px 10px; border-radius: 20px; background: var(--panel-strong); color: var(--muted); font-weight: 700; letter-spacing: 0.3px; }
    .badge { display: inline-block; padding: 6px 10px; border-radius: 10px; background: #1c2738; color: var(--text); border: 1px solid rgba(255,255,255,0.1); }
    .slider-row { display: flex; align-items: center; gap: 10px; }
    input[type="range"] { width: 160px; accent-color: var(--accent); }
    canvas#game { width: 100%; height: 420px; background: #0c1120; border-radius: 14px; border: 1px solid rgba(255,255,255,0.08); box-shadow: inset 0 0 20px rgba(0,0,0,0.4); }
    canvas#chart { width: 100%; height: 180px; background: #0d101c; border-radius: 10px; border: 1px solid rgba(255,255,255,0.07); }
    .list { list-style: none; padding: 0; margin: 0; display: grid; gap: 6px; }
    .list li { background: var(--panel-strong); padding: 8px 10px; border-radius: 10px; }
    .bar { height: 8px; background: rgba(255,255,255,0.08); border-radius: 10px; overflow: hidden; }
    .bar span { display: block; height: 100%; background: linear-gradient(90deg, #ff6b6b, #6c5ce7); }
    @media (max-width: 1000px) { .layout { grid-template-columns: 1fr; } header { flex-direction: column; align-items: flex-start; } }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Shadow Arena – Online lernender KI-Buddy</h1>
      <div class="tagline">Steuere den Runner mit WASD. Sammle Energie-Orbs, weiche Gefahren aus. Ein KI-Buddy beobachtet dich und lernt per Online-Behavior-Cloning in Echtzeit deine Aktionen nachzuahmen, um dir zu helfen.</div>
    </div>
    <div class="row">
      <span class="pill" id="modeLabel">Modus: Beobachten</span>
      <span class="pill" id="episodeLabel">Episode 1</span>
    </div>
  </header>

  <section class="layout">
    <div class="card">
      <h2>Game-View</h2>
      <canvas id="game" width="960" height="420"></canvas>
      <div class="stat-grid" style="margin-top: 10px;">
        <div class="stat"><div class="label">Player HP</div><div class="value" id="hpStat">100</div></div>
        <div class="stat"><div class="label">Score</div><div class="value" id="scoreStat">0</div></div>
        <div class="stat"><div class="label">KI Score</div><div class="value" id="allyStat">0</div></div>
        <div class="stat"><div class="label">Timer</div><div class="value" id="timeStat">0</div></div>
      </div>
    </div>

    <div class="col">
      <div class="card">
        <h2>KI-Status</h2>
        <div class="row">
          <span class="badge" id="aiDecision">-</span>
          <span class="badge" id="aiMode">Online-Lernen</span>
          <span class="badge" id="autoTrainBadge">Auto-Training: an</span>
        </div>
        <div class="stat-grid" style="margin-top:10px;">
          <div class="stat"><div class="label">Samples</div><div class="value" id="sampleCount">0</div></div>
          <div class="stat"><div class="label">Updates</div><div class="value" id="updateCount">0</div></div>
          <div class="stat"><div class="label">Epsilon</div><div class="value" id="epsilonVal">0.1</div></div>
          <div class="stat"><div class="label">LR</div><div class="value" id="lrVal">0.05</div></div>
        </div>
        <div class="list" id="featureList"></div>
      </div>

      <div class="card">
        <h2>Lernkurve</h2>
        <canvas id="chart" width="520" height="180"></canvas>
      </div>
    </div>
  </section>

  <section class="layout" style="margin-top: 14px; grid-template-columns: 1.2fr 1fr 1fr;">
    <div class="card">
      <h2>Modell-Panel</h2>
      <div class="row" style="justify-content: space-between;">
        <div class="badge">Features: <span id="featCount">0</span></div>
        <div class="badge">Aktionen: <span id="actCount">0</span></div>
      </div>
      <div class="list" id="weightList" style="margin-top:8px;"></div>
    </div>

    <div class="card">
      <h2>Kontrollen</h2>
      <div class="slider-row">
        <label>Learning Rate</label>
        <input type="range" id="lrSlider" min="0.01" max="0.5" step="0.01" value="0.05">
        <span class="badge" id="lrLabel">0.05</span>
      </div>
      <div class="slider-row">
        <label>Exploration ε</label>
        <input type="range" id="epsSlider" min="0" max="0.6" step="0.02" value="0.10">
        <span class="badge" id="epsLabel">0.10</span>
      </div>
      <div class="col" style="margin-top: 6px;">
        <button id="resetModel" class="secondary">KI-Model Reset</button>
        <button id="resetData" class="secondary">Daten zurücksetzen</button>
        <button id="newRound" class="danger">Neue Runde</button>
      </div>
      <p style="color: var(--muted); margin: 6px 0 0; font-size: 0.9rem;">Der KI-Buddy nutzt Behavior-Cloning: jeder Spielerzug wird als (State, Action)-Paar gespeichert und mittels SGD trainiert, um deine Steuerung zu imitieren. Epsilon erzeugt Zufallsaktionen zum Erkunden.</p>
    </div>

    <div class="card">
      <h2>Episode/Performance</h2>
      <div class="list" id="episodeList"></div>
    </div>
  </section>

  <script>
    // --- Game constants ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const chartCanvas = document.getElementById('chart');
    const chartCtx = chartCanvas.getContext('2d');
    const W = canvas.width; const H = canvas.height;
    const keys = { w:false, a:false, s:false, d:false };
    const actions = ['up','down','left','right','idle']; // action space

    // --- Entities ---
    let player, ally, orbs, enemies, obstacles;
    let score = 0, allyScore = 0, hp = 100, timer = 60, episode = 1, difficulty = 1;
    let samples = [], updates = 0, episodeHistory = [];
    let autoTrain = true;
    let lastTime = 0, running = true, dt = 0;
    const maxSamples = 800;

    // --- Model parameters ---
    let lr = 0.05; // learning rate
    let epsilon = 0.1; // exploration
    const inputSize = 10; // dx/dy player->orb/enemy, player velocity, ally relative
    const hiddenSize = 12;
    const outputSize = actions.length;
    let W1, b1, W2, b2;

    // --- DOM refs ---
    const hpStat = document.getElementById('hpStat');
    const scoreStat = document.getElementById('scoreStat');
    const allyStat = document.getElementById('allyStat');
    const timeStat = document.getElementById('timeStat');
    const sampleCount = document.getElementById('sampleCount');
    const updateCount = document.getElementById('updateCount');
    const epsilonVal = document.getElementById('epsilonVal');
    const lrVal = document.getElementById('lrVal');
    const featureList = document.getElementById('featureList');
    const modeLabel = document.getElementById('modeLabel');
    const episodeLabel = document.getElementById('episodeLabel');
    const aiDecision = document.getElementById('aiDecision');
    const aiMode = document.getElementById('aiMode');
    const autoTrainBadge = document.getElementById('autoTrainBadge');
    const featCount = document.getElementById('featCount');
    const actCount = document.getElementById('actCount');
    const weightList = document.getElementById('weightList');
    const episodeList = document.getElementById('episodeList');
    const lrSlider = document.getElementById('lrSlider');
    const epsSlider = document.getElementById('epsSlider');
    const lrLabel = document.getElementById('lrLabel');
    const epsLabel = document.getElementById('epsLabel');

    // --- Utility functions ---
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const sign = v => v>=0?1:-1;

    function randn(scale=1){ return (Math.random()*2-1)*scale; }
    function zeros(len){ return new Array(len).fill(0); }

    function initModel(){
      W1 = Array.from({length: hiddenSize}, ()=> Array.from({length: inputSize}, ()=>randn(0.5)));
      b1 = Array.from({length: hiddenSize}, ()=>randn(0.1));
      W2 = Array.from({length: outputSize}, ()=> Array.from({length: hiddenSize}, ()=>randn(0.5)));
      b2 = Array.from({length: outputSize}, ()=>randn(0.1));
      updates = 0;
      updateModelView();
    }

    // Forward pass: returns logits and cache
    function forward(state){
      const h = zeros(hiddenSize);
      for(let i=0;i<hiddenSize;i++){
        let sum = b1[i];
        for(let j=0;j<inputSize;j++) sum += W1[i][j]*state[j];
        h[i] = Math.max(0, sum); // ReLU
      }
      const o = zeros(outputSize);
      for(let k=0;k<outputSize;k++){
        let sum = b2[k];
        for(let i=0;i<hiddenSize;i++) sum += W2[k][i]*h[i];
        o[k] = sum;
      }
      return {h, o};
    }

    function softmax(logits){
      const max = Math.max(...logits);
      const exps = logits.map(v=>Math.exp(v-max));
      const sum = exps.reduce((a,b)=>a+b,0);
      return exps.map(v=>v/sum);
    }

    // Backprop for single sample, cross-entropy
    function trainStep(state, actionIdx){
      const {h, o} = forward(state);
      const probs = softmax(o);
      const gradLogits = probs.map((p,idx)=> p - (idx===actionIdx?1:0));
      // dW2, db2
      for(let k=0;k<outputSize;k++){
        for(let i=0;i<hiddenSize;i++){
          W2[k][i] -= lr * gradLogits[k] * h[i];
        }
        b2[k] -= lr * gradLogits[k];
      }
      const gradH = zeros(hiddenSize);
      for(let i=0;i<hiddenSize;i++){
        let sum = 0; for(let k=0;k<outputSize;k++) sum += gradLogits[k]*W2[k][i];
        gradH[i] = sum * (h[i]>0?1:0);
      }
      for(let i=0;i<hiddenSize;i++){
        for(let j=0;j<inputSize;j++){
          W1[i][j] -= lr * gradH[i] * state[j];
        }
        b1[i] -= lr * gradH[i];
      }
      updates++;
    }

    // --- Game setup ---
    function initGame(){
      player = {x: W*0.25, y: H*0.5, r: 12, speed: 160, vx:0, vy:0};
      ally   = {x: W*0.6, y: H*0.5, r: 10, speed: 150, vx:0, vy:0};
      score = 0; allyScore = 0; hp = 100; timer = 60;
      orbs = []; enemies = []; obstacles = [];
      for(let i=0;i<5;i++) spawnOrb();
      for(let i=0;i<3;i++) spawnEnemy();
      createObstacles();
      modeLabel.textContent = 'Modus: Beobachten & Lernen';
      episodeLabel.textContent = `Episode ${episode}`;
      updateHUD();
      featureList.innerHTML = renderFeatures();
      running = true;
    }

    function createObstacles(){
      obstacles = [
        {x: W*0.3, y: H*0.2, w: 120, h: 18},
        {x: W*0.55, y: H*0.7, w: 160, h: 20},
        {x: W*0.15, y: H*0.6, w: 100, h: 20},
      ];
    }

    function spawnOrb(){
      orbs.push({x: rand(40, W-40), y: rand(40, H-40), r: 8});
    }

    function spawnEnemy(){
      enemies.push({x: rand(60, W-60), y: rand(60, H-60), r: 12, speed: 90 + difficulty*10, dir: Math.random()*Math.PI*2});
    }

    // --- Input ---
    window.addEventListener('keydown', e=>{ if(['w','a','s','d'].includes(e.key)) keys[e.key]=true; });
    window.addEventListener('keyup', e=>{ if(['w','a','s','d'].includes(e.key)) keys[e.key]=false; });

    // --- State vector for agent ---
    // [dx_to_player, dy_to_player, dx_to_orb, dy_to_orb, dx_to_enemy, dy_to_enemy, ally_vx, ally_vy, player_vx, player_vy]
    function getState(){
      const nearestOrb = orbs.reduce((best,o)=>{
        const d = (o.x-ally.x)**2 + (o.y-ally.y)**2; return d < best.dist? {obj:o, dist:d}: best; 
      }, {obj:null, dist: Infinity}).obj || {x:ally.x, y:ally.y};
      const nearestEnemy = enemies.reduce((best,en)=>{
        const d = (en.x-ally.x)**2 + (en.y-ally.y)**2; return d < best.dist? {obj:en, dist:d}: best; 
      }, {obj:null, dist: Infinity}).obj || {x:ally.x, y:ally.y};
      const state = [
        (player.x - ally.x)/W,
        (player.y - ally.y)/H,
        (nearestOrb.x - ally.x)/W,
        (nearestOrb.y - ally.y)/H,
        (nearestEnemy.x - ally.x)/W,
        (nearestEnemy.y - ally.y)/H,
        ally.vx/ally.speed,
        ally.vy/ally.speed,
        player.vx/player.speed,
        player.vy/player.speed
      ];
      return state;
    }

    function playerAction(){
      let ax=0, ay=0;
      if(keys.w) ay -= 1;
      if(keys.s) ay += 1;
      if(keys.a) ax -= 1;
      if(keys.d) ax += 1;
      const len = Math.hypot(ax,ay)||1;
      ax/=len; ay/=len;
      player.vx = ax * player.speed; player.vy = ay * player.speed;
      player.x = clamp(player.x + player.vx*dt, player.r, W-player.r);
      player.y = clamp(player.y + player.vy*dt, player.r, H-player.r);
      collideObstacles(player);
      // return chosen action index for training
      let idx = 4; // idle
      if(ax||ay){
        if(Math.abs(ax)>Math.abs(ay)) idx = ax>0?3:2; // right/left
        else idx = ay>0?1:0; // down/up
      }
      return idx;
    }

    function collideObstacles(obj){
      obstacles.forEach(o=>{
        if(obj.x+obj.r>o.x && obj.x-obj.r<o.x+o.w && obj.y+obj.r>o.y && obj.y-obj.r<o.y+o.h){
          // push back
          const left = obj.x - o.x; const right = (o.x+o.w) - obj.x; const top = obj.y - o.y; const bottom = (o.y+o.h) - obj.y;
          const minPen = Math.min(left, right, top, bottom);
          if(minPen===left) obj.x = o.x - obj.r;
          else if(minPen===right) obj.x = o.x + o.w + obj.r;
          else if(minPen===top) obj.y = o.y - obj.r;
          else obj.y = o.y + o.h + obj.r;
        }
      });
    }

    function allyStep(){
      const state = getState();
      let actionIdx;
      if(Math.random() < epsilon){
        actionIdx = Math.floor(Math.random()*actions.length);
        aiMode.textContent = 'Exploration';
      } else {
        aiMode.textContent = 'Exploitation';
        const {o} = forward(state);
        const probs = softmax(o);
        actionIdx = probs.indexOf(Math.max(...probs));
      }
      applyAction(ally, actionIdx);
      aiDecision.textContent = `KI möchte: ${actions[actionIdx]}`;
      return {state, actionIdx};
    }

    function applyAction(entity, actionIdx){
      const dirs = {
        'up': [0,-1], 'down':[0,1], 'left':[-1,0], 'right':[1,0], 'idle':[0,0]
      };
      const [ax, ay] = dirs[actions[actionIdx]];
      const len = Math.hypot(ax, ay)||1;
      entity.vx = ax/len * entity.speed;
      entity.vy = ay/len * entity.speed;
      entity.x = clamp(entity.x + entity.vx*dt, entity.r, W-entity.r);
      entity.y = clamp(entity.y + entity.vy*dt, entity.r, H-entity.r);
      collideObstacles(entity);
    }

    function updateEnemies(){
      enemies.forEach(en=>{
        en.x += Math.cos(en.dir)*en.speed*dt;
        en.y += Math.sin(en.dir)*en.speed*dt;
        if(en.x<en.r||en.x>W-en.r) en.dir = Math.PI - en.dir;
        if(en.y<en.r||en.y>H-en.r) en.dir = -en.dir;
        collideObstacles(en);
      });
    }

    function handleCollisions(){
      // player collect orbs
      orbs = orbs.filter(o=>{
        const dP = Math.hypot(o.x-player.x, o.y-player.y);
        const dA = Math.hypot(o.x-ally.x, o.y-ally.y);
        if(dP < player.r + o.r){ score += 10; spawnOrb(); return false; }
        if(dA < ally.r + o.r){ allyScore += 6; spawnOrb(); return false; }
        return true;
      });
      // enemies damage player
      enemies.forEach(en=>{
        const dP = Math.hypot(en.x-player.x, en.y-player.y);
        if(dP < en.r + player.r){ hp = Math.max(0, hp-20*dt); }
        const dA = Math.hypot(en.x-ally.x, en.y-ally.y);
        if(dA < en.r + ally.r){ en.dir += Math.PI/2; }
      });
    }

    function updateHUD(){
      hpStat.textContent = hp.toFixed(0);
      scoreStat.textContent = score.toFixed(0);
      allyStat.textContent = allyScore.toFixed(0);
      timeStat.textContent = timer.toFixed(1);
      sampleCount.textContent = samples.length;
      updateCount.textContent = updates;
      epsilonVal.textContent = epsilon.toFixed(2);
      lrVal.textContent = lr.toFixed(2);
      autoTrainBadge.textContent = `Auto-Training: ${autoTrain?'an':'aus'}`;
    }

    function render(){
      ctx.clearRect(0,0,W,H);
      // background grid
      ctx.fillStyle = '#0c1120';
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for(let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

      // obstacles
      obstacles.forEach(o=>{
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.strokeRect(o.x, o.y, o.w, o.h);
      });

      // orbs
      orbs.forEach(o=>{
        ctx.beginPath();
        const grad = ctx.createRadialGradient(o.x, o.y, 2, o.x, o.y, 10);
        grad.addColorStop(0, '#7cf0ff');
        grad.addColorStop(1, '#2f9ecb');
        ctx.fillStyle = grad;
        ctx.arc(o.x,o.y,o.r,0,Math.PI*2);
        ctx.fill();
      });

      // enemies
      enemies.forEach(en=>{
        ctx.beginPath();
        const grad = ctx.createRadialGradient(en.x, en.y, 2, en.x, en.y, 14);
        grad.addColorStop(0, '#ff6b6b');
        grad.addColorStop(1, '#c0392b');
        ctx.fillStyle = grad;
        ctx.arc(en.x,en.y,en.r,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.stroke();
      });

      // ally trail
      ctx.strokeStyle = 'rgba(124, 240, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(ally.x, ally.y, ally.r+6, 0, Math.PI*2);
      ctx.stroke();

      // ally
      ctx.beginPath();
      ctx.fillStyle = '#7cf0ff';
      ctx.arc(ally.x, ally.y, ally.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0c1120';
      ctx.fillRect(ally.x-2, ally.y-6, 4, 3);

      // player
      ctx.beginPath();
      ctx.fillStyle = '#feca57';
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0c1120';
      ctx.fillRect(player.x-2, player.y-6, 4, 3);

      // UI overlay text
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '12px Inter';
      ctx.fillText('WASD bewegen · Sammle Blau, meide Rot · KI lernt dein Verhalten', 12, 16);
    }

    // --- Chart ---
    function drawChart(){
      chartCtx.clearRect(0,0,chartCanvas.width, chartCanvas.height);
      chartCtx.fillStyle = '#0d101c';
      chartCtx.fillRect(0,0,chartCanvas.width, chartCanvas.height);
      chartCtx.strokeStyle = 'rgba(255,255,255,0.1)';
      for(let x=0;x<chartCanvas.width;x+=40){ chartCtx.beginPath(); chartCtx.moveTo(x,0); chartCtx.lineTo(x,chartCanvas.height); chartCtx.stroke(); }
      for(let y=0;y<chartCanvas.height;y+=40){ chartCtx.beginPath(); chartCtx.moveTo(0,y); chartCtx.lineTo(chartCanvas.width,y); chartCtx.stroke(); }
      if(episodeHistory.length<2) return;
      const maxReward = Math.max(...episodeHistory.map(e=>e.reward), 1);
      chartCtx.strokeStyle = '#7cf0ff';
      chartCtx.lineWidth = 2;
      chartCtx.beginPath();
      episodeHistory.forEach((ep,idx)=>{
        const x = (idx/(episodeHistory.length-1)) * (chartCanvas.width-20) + 10;
        const y = chartCanvas.height - (ep.reward/maxReward)*(chartCanvas.height-20) - 10;
        if(idx===0) chartCtx.moveTo(x,y); else chartCtx.lineTo(x,y);
      });
      chartCtx.stroke();
      chartCtx.fillStyle = '#7cf0ff';
      episodeHistory.forEach((ep,idx)=>{
        const x = (idx/(episodeHistory.length-1)) * (chartCanvas.width-20) + 10;
        const y = chartCanvas.height - (ep.reward/maxReward)*(chartCanvas.height-20) - 10;
        chartCtx.beginPath(); chartCtx.arc(x,y,3,0,Math.PI*2); chartCtx.fill();
      });
    }

    function renderEpisodes(){
      episodeList.innerHTML = episodeHistory.slice(-6).map(ep=>
        `<li>Ep ${ep.id}: Reward ${ep.reward.toFixed(1)} · Player ${ep.playerScore} · KI ${ep.allyScore}</li>`
      ).join('');
    }

    // --- Training loop ---
    function recordSample(state, actionIdx){
      if(samples.length > maxSamples) samples.shift();
      samples.push({state, actionIdx});
      // sofortiges Online-Update, damit die KI ohne Button-Eingriff automatisch lernt
      if(autoTrain){
        trainStep(state, actionIdx);
        if(updates % 4 === 0) updateModelView();
      }
    }

    function trainMiniBatch(batchSize=12){
      if(samples.length===0) return;
      for(let i=0;i<batchSize;i++){
        const sample = samples[Math.floor(Math.random()*samples.length)];
        trainStep(sample.state, sample.actionIdx);
      }
      updateModelView();
    }

    function updateModelView(){
      featCount.textContent = inputSize;
      actCount.textContent = outputSize;
      // visualize first hidden neuron weights
      const names = [
        'ally->player dx','ally->player dy','ally->orb dx','ally->orb dy','ally->enemy dx','ally->enemy dy','ally vx','ally vy','player vx','player vy'
      ];
      weightList.innerHTML = names.map((name, idx)=>{
        const avg = W1.reduce((a,row)=>a+row[idx],0)/hiddenSize;
        const width = clamp((avg+1)/2, 0, 1)*100;
        const color = avg>0? 'linear-gradient(90deg,#7cf0ff,#6c5ce7)':'linear-gradient(90deg,#ff9ff3,#ff6b81)';
        return `<li><div class="row" style="justify-content: space-between;"><span>${name}</span><span>${avg.toFixed(2)}</span></div><div class="bar"><span style="width:${width}%; background:${color}"></span></div></li>`;
      }).join('');
    }

    function renderFeatures(){
      return `
        <li>State: [ally→player Δx/Δy, ally→orb Δx/Δy, ally→enemy Δx/Δy, ally vx/vy, player vx/vy]</li>
        <li>Aktionen: ${actions.join(', ')}</li>
        <li>Training: Cross-Entropy, ReLU Hidden ${hiddenSize}, Lernrate anpassbar</li>
        <li>Online-Update: jede Sekunde Mini-Batch & Sofort-Update bei jedem Spielerzug</li>
      `;
    }

    // --- Episode management ---
    function endEpisode(){
      running = false;
      const reward = allyScore - (100-hp)*0.2 + score*0.2;
      episodeHistory.push({id: episode, reward, playerScore: score, allyScore});
      drawChart();
      renderEpisodes();
      difficulty += 0.3;
      episode++;
      modeLabel.textContent = 'Episode beendet';
      setTimeout(()=>{ resetEpisode(); }, 800);
    }

    function resetEpisode(){
      initGame();
      running = true;
    }

    // --- Controls ---
    document.getElementById('resetModel').onclick = ()=>{ initModel(); };
    document.getElementById('resetData').onclick = ()=>{ samples=[]; updates=0; episodeHistory=[]; drawChart(); renderEpisodes(); updateHUD(); };
    document.getElementById('newRound').onclick = ()=>{ endEpisode(); };
    lrSlider.oninput = ()=>{ lr = parseFloat(lrSlider.value); lrLabel.textContent = lr.toFixed(2); lrVal.textContent = lr.toFixed(2); };
    epsSlider.oninput = ()=>{ epsilon = parseFloat(epsSlider.value); epsLabel.textContent = epsilon.toFixed(2); epsilonVal.textContent = epsilon.toFixed(2); };

    // --- Main loop ---
    let trainAccumulator = 0;
    function loop(ts){
      if(!lastTime) lastTime = ts;
      dt = (ts-lastTime)/1000;
      lastTime = ts;
      if(running){
        timer -= dt; if(timer<=0 || hp<=0) endEpisode();
        const playerAct = playerAction();
        const {state, actionIdx} = allyStep();
        recordSample(state, playerAct); // target is player action for imitation
        updateEnemies();
        handleCollisions();
        updateHUD();
        trainAccumulator += dt;
        if(trainAccumulator > 1){ // once per second run minibatch
          trainMiniBatch();
          trainAccumulator = 0;
        }
        aiDecision.textContent += ` | Spieler: ${actions[playerAct]}`;
      }
      render();
      requestAnimationFrame(loop);
    }

    // --- Start ---
    initModel();
    initGame();
    updateModelView();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
